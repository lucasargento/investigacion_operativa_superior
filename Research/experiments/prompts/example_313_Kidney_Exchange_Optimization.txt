You are an expert in translating MiniZinc models to Python using OR-Tools. Your task is to translate the following optimization problem:

Problem Information:
- Example Number: 313
- Name: Kidney Exchange Optimization
- Domain: Healthcare
- Objective: maximization

Problem Description:
The problem is a simple model of kidney exchange, inspired by Pascal Van Hentenryck's introduction of the Coursera Course Discrete Optimization. The objective is to maximize the number of kidney exchanges given the compatibility. A person receiving a kidney must be able to give a kidney, which means we are looking for cycles. The problem is defined for a certain number of people, and for each person, there is a set of people who are compatible with them for a kidney exchange. The problem also considers people that have no potential donors and can't get a kidney. The decision variables are which kidney does person p get (or p if he/she gets no kidney) and the total number of people who get a kidney. The constraints ensure that only the compatible people are in the domains and remove incompatible people. The problem is to find the assignment of kidneys to people that maximizes the total number of people who get a kidney.


Input Data (data.dzn):
%
% Generated by 
%   kidney_exchange.pl 40 0.05 or_tools
%  
%
num_people = 40;
compatible = 
[ 
{24,35}, % 1
{27,35}, % 2
{7,35}, % 3
{6,29}, % 4
{38}, % 5
{33}, % 6
{14,31}, % 7
{25}, % 8
{27,34}, % 9
{1,11}, % 10
{6,14,32}, % 11
{9,36}, % 12
{19,26,30}, % 13
{15,37}, % 14
{20,23,37}, % 15
{32,39}, % 16
{8,9,36}, % 17
{38}, % 18
{18,28}, % 19
{4,23,26}, % 20
{20}, % 21
{35}, % 22
{12,36}, % 23
{9,25}, % 24
{9,24}, % 25
{40}, % 26
{8,34,37}, % 27
{4,8,18,23}, % 28
{1,14,31,33}, % 29
{12,29}, % 30
{21}, % 31
{22,34}, % 32
{32}, % 33
{14,29}, % 34
{6,40}, % 35
{10,13,17,26}, % 36
{27,34}, % 37
{1}, % 38
{35}, % 39
{25,28}, % 40
];

MiniZinc Model:
include "globals.mzn"; 

int: num_people;
array[1..num_people] of set of int: compatible;

% people that has no no potential donors (and can't get a kidney)
set of 1..num_people: non_compatible = { p | p in 1..num_people where card(compatible[p]) = 0 };

% The domains for each person
array[1..num_people] of set of int: 
   compatible_pruned = [ 
            if card(compatible[p]) = 0 then {p} else (compatible[p] diff non_compatible) union {p} endif
   | p in 1..num_people ];

%
% decision variables
%

% which kidney does person p get (or p if he/she gets no kidney)
array[1..num_people] of var 1..num_people: x;
var 0..num_people: z = sum([bool2int(x[i] != i) | i in 1..num_people]);



% solve satisfy;
% solve maximize z;
solve :: int_search(
      x,
      first_fail, 
      indomain_median,
      complete) 
    maximize z;

% Just allow the compatible people (+ p) in the domains
% and remove uncompatible people.
constraint
  forall(p in 1..num_people) (
     x[p] in compatible_pruned[p]    
  )
  /\
  alldifferent(x)

  % /\ subcircuit(x)

  % first test if all are donors (-> circuit)
  % don't work
  % /\ (circuit(x) \/ subcircuit(x))

;

output [
  "z: " ++ show(z) ++ "\n" ++
  "x: " ++ show(x) ++ "\n" 
]
++
[
  "person: donor\n"
]
++
[
  if fix(x[i] = i) then 
     show_int(3, i) ++ ":   -\n"
  else 
     show_int(3, i) ++ ": " ++  show_int(3, x[i]) ++ "\n"
  endif
  | i in 1..num_people
]
++
[
  show(x) ++ "\n"
  ++ "z: " ++ show(z) ++ "\n" 
];


%
% data
%

% The compatibility matrix 
% (from Pascal's introduction lecture)
% who can give a kidney to person p
% This is a directed graph
% num_people = 8;
% compatible = 
%   [
%     {2,3}, % 1
%     {1,6}, % 2
%     {1,4,7}, % 3
%     {2}, % 4  
%     {2}, % 5
%     {5}, % 6
%     {8}, % 7
%     {3}, % 8
%   ];

Expected Output:
{
  "x": [
    24,
    2,
    3,
    29,
    5,
    33,
    7,
    8,
    27,
    10,
    11,
    36,
    19,
    15,
    23,
    16,
    17,
    38,
    18,
    26,
    20,
    35,
    12,
    25,
    9,
    40,
    37,
    4,
    31,
    30,
    21,
    22,
    32,
    14,
    6,
    13,
    34,
    1,
    39,
    28
  ],
  "_objective": 29
}

Instructions:
1. If a MiniZinc model is provided, translate it directly to Python using OR-Tools.
2. If no MiniZinc model is provided, first create a MiniZinc model and then translate it to Python.
3. The Python code should be complete and executable as-is.
4. Include all necessary imports and dependencies.
5. Define all variables before use.
6. Use explicit loops instead of list comprehensions.
7. Ensure the solution matches the expected output format.
8. Include comments explaining key parts of the implementation.

Please provide the complete Python code that solves this optimization problem using OR-Tools.