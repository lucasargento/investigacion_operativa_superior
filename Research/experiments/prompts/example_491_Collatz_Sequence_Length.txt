You are an expert in translating MiniZinc models to Python using OR-Tools. Your task is to translate the following optimization problem:

Problem Information:
- Example Number: 491
- Name: Collatz Sequence Length
- Domain: Number Theory
- Objective: satisfaction

Problem Description:
The problem is based on the Collatz conjecture, which is a sequence defined as follows: t(x) = x/2 if x is even, t(x) = (3x+1)/2 if x is odd. The task is to generate a Collatz sequence for a given number 'n' and calculate the length of the sequence until the number 1 is reached for the first time. The sequence is represented as an array 'x' of length 'max_len', which is three times the value of 'n'. The length of the sequence until the first occurrence of 1 is represented by the variable 'len'. The sequence must satisfy the conditions of the Collatz conjecture, i.e., each element 'x[i]' in the sequence must be either half of 'x[i-1]' if 'x[i-1]' is even, or (3*'x[i-1]'+1)/2 if 'x[i-1]' is odd. The sequence must also satisfy the condition that there exists an index 'i' such that 'x[i]' is 1 and 'len' is 'i-1', and all elements before 'x[i]' are greater than 1. The goal is to find a sequence that satisfies all these conditions.


MiniZinc Model:
int: n = 117;
int: max_len = 3*n;

% decision variables
% Note: after 1 is reached the first time (at length len) then the
%       values toggles between 1 and 2.
% array[1..max_len] of var int: x;
array[1..max_len] of var 0..100000: x;
var 0..max_len: len; % the length of the sequence until (first) reaching 1


solve :: int_search(x, first_fail, indomain_split, complete) satisfy;

predicate collatz(var int: x, var int: y) =
      (x mod 2 = 0 -> y = x div 2) /\
      (x mod 2 = 1 -> y = ((3*x)+1) div 2)
;

constraint
   x[1] = n
   /\
   forall(i in 2..max_len) (
      x[i] >= 1 
      /\
      x[i-1] >= 1
      /\
      collatz(x[i-1], x[i])
      % /\ x[i] <= n*n*n % upper bound for ECLiPSe/ic
   )

   /\
   exists(i in 1..max_len) (
      x[i] = 1
      /\
      len = (i-1) /\ forall(j in 1..i-1) (x[j] > 1)
   )

   % /\
   % x = [5, 8, 4, 2, 1] % n = 5
   %  x = [12, 6, 3, 5, 8, 4, 2, 1] %  n = 12
   % x = [6, 3, 5, 8, 4, 2, 1] % n = 6
;


output [
   "n: " ++ show(n) ++ "\n" ++
   "len: " ++ show(len) ++ "\n" ++
   "x: " ++ show(x) ++ "\n"
];

Expected Output:
{
  "x": [
    117,
    176,
    88,
    44,
    22,
    11,
    17,
    26,
    13,
    20,
    10,
    5,
    8,
    4,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2,
    1,
    2
  ],
  "len": 15
}

Instructions:
1. If a MiniZinc model is provided, translate it directly to Python using OR-Tools.
2. If no MiniZinc model is provided, first create a MiniZinc model and then translate it to Python.
3. The Python code should be complete and executable as-is.
4. Include all necessary imports and dependencies.
5. Define all variables before use.
6. Use explicit loops instead of list comprehensions.
7. Ensure the solution matches the expected output format.
8. Include comments explaining key parts of the implementation.

Please provide the complete Python code that solves this optimization problem using OR-Tools.